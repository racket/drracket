#undef l_ADDRESS
#undef l_DEREF
#undef l_TEST
#undef l_POINT
#undef l_TYPE
#undef l_LIST_ITEM_BUNDLE
#undef l_LIST_ITEM_UNBUNDLE
#undef l_MAKE_LIST
#undef l_MAKE_ARRAY
#undef l_EXTRA
#undef l_TERMINATE
#undef l_COPY
#undef l_OKTEST
#undef l_INTTYPE

@IFDEFINE l_ADDRESS = INDIRECT : & : 
@IFDEFINE l_DEREF = INDIRECT : * : 
@IFDEFINE l_NULLOK = ALLOWNULL : 1 : 0
@IFDEFINE l_TEST = NOTEST :  : , l_NULLOK
@IFDEFINE l_POINT = POINTERS : * : 
@IFDEFINE l_EXTRA = NULLTERM : 1 : 0
@IFDEFINE l_TERMINATE = NULLTERM : f[i] = 0; :
@IFDEFINE l_COPY = POINTWISE : l_COPYDEST.x=l_COPYSRC.x; l_COPYDEST.y=l_COPYSRC.y; : l_COPYDEST=l_COPYSRC;
@IFDEFINE l_OKTEST = DOOKTEST : if (!((l_COPYDEST)->Ok())) scheme_signal_error("%s: bad bitmap", OKTESTWHERE);
@IFDEFINE l_INTTYPE = SIZEISLONG : long : int

@DEFINE l_TYPE = <TYPE>
@DEFINE l_LIST_ITEM_BUNDLE = objscheme_bundle_<TYPE>
@DEFINE l_LIST_ITEM_UNBUNDLE = objscheme_unbundle_<TYPE>
@DEFINE l_MAKE_LIST = __Make<TYPE>List
@DEFINE l_MAKE_ARRAY = __Make<TYPE>Array

@MACRO bList = NULL
@MACRO ubList = NULL
@MACRO cList = SCHEME_LISTP({x})

@MACRO glueListSet[type.list.array.cnt.who] = x<array> = __Make<type>Array((<list> < n) ? p[<list>] : scheme_null, &x<cnt>, <who>);
@MACRO glueUncountedListSet[type.list.array.who] = x<array> = __Make<type>Array((<array> < n) ? p[<list>] : scheme_null, NULL, <who>);
@MACRO methListSet[type.list.array.cnt] = p[<list>] = __Make<type>List(x<array>, x<cnt>);

@MACRO glueCleanup[array] = delete[] x<array>;

@MACRO bReturnList[type.cnt] =  __Make<type>List({x}, *x<cnt>);

static Scheme_Object *l_MAKE_LIST(l_TYPE l_POINT *f, l_INTTYPE c)
{
  Scheme_Object *cdr = scheme_null, *obj;

  while (c--) {
    obj = l_LIST_ITEM_BUNDLE(l_ADDRESS f[c]);
    cdr = scheme_make_pair(obj, cdr);
  }
  
  return cdr;
}

static l_TYPE l_POINT *l_MAKE_ARRAY(Scheme_Object *l, l_INTTYPE *c, char *who)
{
  int i = 0;
  long len;

  len = scheme_proper_list_length(l);
  if (len < 0) scheme_wrong_type(who, "proper-list", -1, 0, &l);
  if (c) *c = len;

  if (!(len + l_EXTRA))
    return NULL;

  l_TYPE l_POINT *f = new l_TYPE l_POINT[len + l_EXTRA];

  while (!SCHEME_NULLP(l)) {
    if (!SCHEME_LISTP(l))
     scheme_signal_error("%s: expected a proper list", who);

#define l_COPYDEST f[i]
#define l_COPYSRC (l_DEREF l_LIST_ITEM_UNBUNDLE(SCHEME_CAR(l), who l_TEST))

    l_COPY

    l_OKTEST

    i++;

    l = SCHEME_CDR(l);
  }
  l_TERMINATE

  return f;
}

@SET NOTEST = 0
@SET INDIRECT = 0
@SET POINTERS = 0
@SET NULLTERM = 0
@SET ALLOWNULL = 0
@SET POINTWISE = 0
@SET DOOKTEST = 0
